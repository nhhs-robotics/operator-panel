# Operator Station

This is the repo for Nathan Hale Robotics Operator Panel, built competition season 2023. 

The Operator Panel is a custom-built HID device. It's a somewhat typical arcade button panel, but 
customized. 


## Hardware

* Raspberry Pi Pico: https://www.adafruit.com/product/4864
* 

## Getting Started with CircuitPython and VSCode

Getting started with VisualCode and CircuitPython
 

## Custom HID Devices 

https://learn.adafruit.com/custom-hid-devices-in-circuitpython

https://learn.adafruit.com/customizing-usb-devices-in-circuitpython/overview


https://learn.adafruit.com/raspberry-pi-pico-led-arcade-button-midi-controller-fighter

# Building the USB HID Interface 

Since this is a custom HID device, we need to specify the interface between our board and the 
host device/computer. There are two components to this: the HID descriptor, and the HID report. When the device is connected to the host, we send a HID descriptor that specifies which data will be sent in which bit. 
Once the device is running, we send the HID report, that fits the descriptor we sent on boot. 

Both the HID descriptor and the HID report are a little tricky, but in different ways. The HID descriptor 
needs to send a series of bytes that are from the USB HID specification (URL here), and the HID report 
packs all the data into bits. 

## Generating and specifying the USB HID descriptor

One way to create the descriptor is to read the spec and write up the descriptor by hand. This is HARD, unless 
you've got lots of time to become really familiar with the spec. 

Another way is to start with an existing descriptor and modify it. This is okay, but if depending on what you need to 
change, it can be easy to waste a lot of time figuring out exactly what to change and how to do it correctly. 

I found it easiest to use a tool to generate a descriptor for me. I used the Microsoft Waratah tool (https://github.com/microsoft/hidtools). 

Our board had the following widgets/components: 

* 8 buttons
* 4 toggles
* 2 sliders
* 1 joystick (digital, 8-way)

I used the following Waratah input file: 

```

[[applicationCollection]]
usage = ['Generic Desktop', 'Gamepad']

    [[applicationCollection.inputReport]]

        [[applicationCollection.inputReport.physicalCollection]]
        usage = ['Generic Desktop', 'Pointer']

            [[applicationCollection.inputReport.physicalCollection.variableItem]]
            usage = ['Generic Desktop', 'X']
            sizeInBits = 8
            logicalValueRange = 'maxUnsignedSizeRange'

            [[applicationCollection.inputReport.physicalCollection.variableItem]]
            usage = ['Generic Desktop', 'Y']
            sizeInBits = 8
            logicalValueRange = 'maxUnsignedSizeRange'

        [[applicationCollection.inputReport.variableItem]]
        usageRange = ['Button', 'Button 1', 'Button 12']
        logicalValueRange = [0, 1]

        [[applicationCollection.inputReport.variableItem]]
        usage = ['Generic Desktop', 'Hat Switch']
        logicalValueRange = [0, 8]
        physicalValueRange = [0, 315]
        unit = 'degrees'

```

Interpreting this: 

* 2 "pointers", which map to X and Y inputs. This is what we're using for the sliders. 
    * The value of the slider ranges from 0 (default) to a max of an unsigned 8-bit value (255). 
* 12 buttons
    * The first 8 are the actual buttons on our board, the last 4 are toggles. 
        * This doesn't matter to the USB HID interface; it's only relevant in our gamepad code and how the gamepad is used. 
    * Each button has a logical 0/1 value (e.g., 1 bit)
* 1 "Hat Switch"
    * The Hat switch has a value from 0 to 8 (4 bits)
    * The values map from either 0 degress (facing forward/North) to 315 degrees (NW). 
    * I think we ended up using a descriptor that included a "Null" position, that's not shown in the config above
        * The "Null" position mapped to a default/middle position, while 1 mapped to North, and 8 to NW, etc. 

The output of the Waratah tool includes a C++ header file, which can be translated to Python for our 
CircuitPython descriptor: 

```
// AUTO-GENERATED by WaratahCmd.exe

#include <memory>

// HID Usage Tables: 1.3.0
// Descriptor size: 60 (bytes)
// +----------+-------+------------------+
// | ReportId | Kind  | ReportSizeInBits |
// +----------+-------+------------------+
// |        1 | Input |               32 |
// +----------+-------+------------------+
static const uint8_t hidReportDescriptor [] =
{
    0x05, 0x01,          // UsagePage(Generic Desktop[1])
    0x09, 0x05,          // UsageId(Gamepad[5])
    0xA1, 0x01,          // Collection(Application)
    0x85, 0x01,          //     ReportId(1)
    0x09, 0x01,          //     UsageId(Pointer[1])
    0xA1, 0x00,          //     Collection(Physical)
    0x09, 0x30,          //         UsageId(X[48])
    0x09, 0x31,          //         UsageId(Y[49])
    0x15, 0x00,          //         LogicalMinimum(0)
    0x26, 0xFF, 0x00,    //         LogicalMaximum(255)
    0x95, 0x02,          //         ReportCount(2)
    0x75, 0x08,          //         ReportSize(8)
    0x81, 0x02,          //         Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)
    0xC0,                //     EndCollection()
    0x05, 0x09,          //     UsagePage(Button[9])
        0x09, 0x30,          //         UsageId(X[48])
    0x09, 0x31,          //         UsageId(Y[49])
    0x15, 0x00,          //         LogicalMinimum(0)
    0x26, 0xFF, 0x00,    //         LogicalMaximum(255)
    0x95, 0x02,          //         ReportCount(2)
    0x75, 0x08,          //         ReportSize(8)
    0x81, 0x02,          //         Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)
    0xC0,                //     EndCollection()
    0x05, 0x09,          //     UsagePage(Button[9])
    0x19, 0x01,          //     UsageIdMin(Button 1[1])
    0x29, 0x0C,          //     UsageIdMax(Button 12[12])
    0x25, 0x01,          //     LogicalMaximum(1)
    0x95, 0x0C,          //     ReportCount(12)
    0x75, 0x01,          //     ReportSize(1)
    0x81, 0x02,          //     Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)
    0x05, 0x01,          //     UsagePage(Generic Desktop[1])
    0x09, 0x39,          //     UsageId(Hat Switch[57])
    0x46, 0x3B, 0x01,    //     PhysicalMaximum(315)
    0x65, 0x14,          //     Unit('degrees', EnglishRotation, Degrees:1)
    0x25, 0x08,          //     LogicalMaximum(8)
    0x95, 0x01,          //     ReportCount(1)
    0x75, 0x04,          //     ReportSize(4)
    0x81, 0x02,          //     Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)
    0xC0,                // EndCollection()
};
```

You'll see that the input file allows us to specify our input widgets, and then the Waratah tool 
calculates exactly how many bits are needed in the report (in this case, 32 bits-- 2 bytes/16 bits for 
the sliders, 1 byte/8 bits for the buttons, 4 bits for the toggle switches, and 4 bits for the hat). 
While it's "easy" to make this calculation for the report later, it's a nice double-check that you 
calculate things correctly. 

The final descriptor we use is in `boot.py`, and shown below: 

```
## HID Usage Tables: 1.3.0
## Descriptor size: 62 (bytes)
## +----------+-------+------------------+
## | ReportId | Kind  | ReportSizeInBits |
## +----------+-------+------------------+
## |        4 | Input |               32 |
## +----------+-------+------------------+

# This is only one example of a gamepad descriptor, and may not suit your needs.
GAMEPAD_REPORT_DESCRIPTOR = bytes((
    0x05, 0x01,          ## UsagePage(Generic Desktop[1])
    0x09, 0x05,          ## UsageId(Gamepad[5])
    0xA1, 0x01,          ## Collection(Application)
    0x85, 0x04,          ##     ReportId(4)
    0x09, 0x01,          ##     UsageId(Pointer[1])
    0xA1, 0x00,          ##     Collection(Physical)
    0x09, 0x30,          ##         UsageId(X[48])
    0x09, 0x31,          ##         UsageId(Y[49])
    0x15, 0x00,          ##         LogicalMinimum(0)
    0x26, 0xFF, 0x00,    ##         LogicalMaximum(255)
    0x95, 0x02,          ##         ReportCount(2)
    0x75, 0x08,          ##         ReportSize(8)
    0x81, 0x02,          ##         Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)
    0xC0,                ##     EndCollection()
    0x05, 0x09,          ##     UsagePage(Button[9])
    0x19, 0x01,          ##     UsageIdMin(Button 1[1])
    0x29, 0x0C,          ##     UsageIdMax(Button 12[12])
    0x25, 0x01,          ##     LogicalMaximum(1)
    0x95, 0x0C,          ##     ReportCount(12)
    0x75, 0x01,          ##     ReportSize(1)
    0x81, 0x02,          ##     Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition, BitField)
    0x05, 0x01,          ##     UsagePage(Generic Desktop[1])
    0x09, 0x39,          ##     UsageId(Hat Switch[57])
    0x46, 0x3B, 0x01,    ##     PhysicalMaximum(315)
    0x65, 0x14,          ##     Unit('degrees', EnglishRotation, Degrees:1)
    0x15, 0x01,          ##     LogicalMinimum(1)
    0x25, 0x08,          ##     LogicalMaximum(8)
    0x95, 0x01,          ##     ReportCount(1)
    0x75, 0x04,          ##     ReportSize(4)
    0x81, 0x42,          ##     Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NullState, BitField)
    0xC0,                ## EndCollection()
))
```

Notes the last "Input" line: it has a "NullState" flag, which means that any value passed in for the hat switch 
that falls outside of the specified range (in this case, the specified range is 1-8) should be considered a 
"null" value. 

## Generating and sending the HID report

Now that we've told the USB host what to expect, we then need to send a report periodically 
to with the current state of the input widgets. 

In this section, I'm only going to review how we store the data and then send it in a report. 

* Slider values: Stored as an int, one for the X-value, one for the Y-value. We ensure the value is always between 0 and 255. 
    * ```
        self._slider_x = 0 ## Val: 0-256
        self._slider_y = 0 ## Val: 0-256
    ```
* Button values: Stored as an int, where each bit specifies whether a button is pressed or not: 
    * ```self._buttons_state = 0```
* Toggle values: Stored as an int: 
    * ```self._toggles_state = 0```
* Hat value: 
    * ```self._hat = 0   ## Val 0-8, where 1 is 0deg, 8 is 315 deg. 0/null is home```

Updating the button values: 

To press a button:
```
self._buttons_state |= 1 << self._validate_button_number(button) - 1
```
This takes the current button state, and ORs it with a new button state. The new button state 
has a 1 shifted to the position that represents the button. E.g., to press Button 7, we take 
a 1 and right-shift it 6 positions (`0100 0000`); ORing that with the current _buttons_state 
ensures that Button 7 gets pressed/turned on. 

To release a button: 
```
self._buttons_state &= ~(1 << self._validate_button_number(button) - 1)
```
This time we AND the current button state with a 1 that has been right-shifted to the desired 
button position and then bit-flipped. To release Button 7, right-shift a 1 6 positions resulting in `0100 0000`. 
Bit-flip that to get `1011 1111`. ANDing that with the original button state insures that Button 7 
gets turned OFF, and all the other button values stay the same. 

Toggles are handled the same was as buttons, just with 4 bits instead of 8. 

The hat switch is handled the same way as the sliders, just ensuring that the value is always between 0 and 8. 

### Packing bits 

The tricky part is now packing our bits consistently with our HID descriptor. 

Here's the code, then I'll break it down: 

```
struct.pack_into(
    "<BBBB",  ## Little-endian, H: unsigned short (2 bytes), b: signed char (1 byte), B: unsigned char (1 byte)
    self._report, ## Pack into the _report var
    0, ## Offset = 0
    self._joy_x, ## Slider X
    self._joy_y, ## Slider Y
    self._buttons_state, ## Write the button state, little-endian
    packed_toggles_and_hat, ## Write the packed toggles/hat, little-endian
)
```

This uses Python's `struct.pack_into` to pack our bits. 

* The first line specifies how to pack the bits
    * The `<` specifies that we want to pack bits little-endian; this ensures the low-end bits get packed first
        * Recall that, for example, our buttons were stored where Button 1 value was stored in the 0-bit (right-side), and Button 8 was stored in the 7-bit (left-side). But, this `<` ensures that we send the 0-bit first. 
    * The `BBBB` says that we will send 4 data values (this is a not-exact interpretation, but good enough for this explanation), and we want each of the 4 values interepreted as an unsigned byte. 
        * Note: for this HID device, using unsigned bytes is all we need; we're never sending negative numbers. But, if we were using an analog joystick, for example, we'd want to be able to send values from, maybe, -127 to 127. Thus, we'd need a signed char rather than unsigned. 
* The second line specifies the struct to pack bits into. This is our `_report` field.
* Next is the offset; it's 0 here, because we have no offset/we want to write over all the bits. 
* All the rest of the params are the data that will be packed into the `_report` field. 
    * The only new value here is `packed_toggles_and_hat`; this is described below. 

Packing the toggles and hat together: 

Recall, we're keeping track of the toggles and hat seperately. There are many different ways to do this packing, but we do it like this: 
    * Take the toggle bits, which occupy the 4 low bits. 
    * Combine with the hat value, which occupies the 4 high bits. 
    * When we pack this little-endian, the 4 toggle bits get packed right after the 8 button bits, which gives us our 12 "button" bits as described by the HID descriptor; and then the last 4 bits represent the hat value, which is also consistent with the HID descriptor. 

The packing code looks like this: 

```
def _pack_toggles_and_hat(self):
    packed_val = self._toggles_state ## Low 4-bits are the toggles
    packed_val |= self._hat << 4     ## High 4-bits is the hat
    return packed_val
```

Whew! Now that eveything is packed, we can send the report to the USB host, and we're good! 


## Miscellaneous notes: 

* This was really a pain to do on a Mac, because it was hard to inspect any existing USB HID descriptors/reports, or to inspect things for debugging. 
* I relied VERY much on the USB HID specification, but the Waratah tool really made everything SO much easier. 
    * Even with the Waratah tool and documentation, I relied on the USB HID spec to find things that were "off the beaten path"
* I also relied on the FIRST Operator Panel software, which visualizes the connected USB HID devices and which widgets are in what state at what point in time. 


